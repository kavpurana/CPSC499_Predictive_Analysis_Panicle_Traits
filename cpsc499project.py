# -*- coding: utf-8 -*-
"""CPSC499Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kDGp8CdngMyvuXN-kb5PyH9GH6crlFde

### Overall Goal
We need to establish a subtle link between panicle size and yield performance
### What Did The Project Aim to Show?
* Using flowering as a covariate (an independent variable that can influence the outcome of a statistical trial but not of direct interest)
* We conduct a genome wide association study to detect a number of subpopulation specific associations and dissect multitrait peaks using panicle phenotype covariates grain length phenotype statistics

# Predictive Analysis of The Genetic Architecture of Panicle Traits in Oryza sativa

### Supplementary Dataset 5
Explores pleiotropy of shared genetic regions which affect multiple traits (search for Supplementary Dataset 5 in article)
* Uses covariate phenotypic traits in a GWAS
* Highlights QLTs or SNPs (regions of genome) associated with multiple traits
  * Helps us identify genetic locus that effect traits that we are selecting
  * Can we specifically find loci that result in traits such as yield or panicle size?
* Also gives information on subpopulations such as Indica or Japonica which might show show certain SNPs are significant in their subpopulations
  * Do one of the subpopulations Indica, Japonica, Aus, Ind, or Trj show more significant results in SNPs or QTLs where yield or panicle size is greater?

### Background definitions:
* QTLs - Quantitative trait locus:
  * statistical method of linking phenotypic data (trait measurements) and genotypic data (molecular markers)
  * allows researchers to link certain complex phenotypes (***such as panicle flowering) to specific regions of chromosomes
* SNPs - Single Nucleotide  Polymorphisms:
  * variation in DNA sequence where a nucleotide base pair differs between individuals at a specific location in the genome
  *  AAGCCTA <-> AAGCTTA (two alleles)
  * acts as a marker
  * this can link to specific traits or diseases
  * most abundant type of genetic variation in human genome
  * deletions, insertions, or substitutions
* Covariate:
  * how factors other than the main variable of interest can affect the outcome of a genetic study
  * since we are looking at pleitropy its important to have other traits be covariates so we can see the correlation of QTLs with the traits
* pleitropy:
  * single gene or mutation affects multiple traits or characteristics
  * people used to think one gene = one trait
  * Similar seeing if one gene = flowering and  
* genetic locus or loci:
  * specific physical location of a gene or other DNA sequence on a chromosome like a genetic street address
  * loci is plural
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import statsmodels.api as sm
!pip install dash_bio

df = pd.read_csv("/content/Supplementary_Data_5.txt", sep = '\t')

df.to_csv('Supplementary_data_5.csv', index = None)

df.loc[df['TRAIT'] == 'totGW']

df.loc[df['TRAIT'] == '1000GW']

df['SUB_POP'].unique()

#drop all null values
df = df.dropna()

df.describe()

"""### My Objectives
Based on this dataset:
1. Can we specifically find loci that result in traits such as yield or panicle size?
2. Do one of the subpopulations Indica, Japonica, Aus, Ind, or Trj show more significant results in SNPs or QTLs where yield or panicle size is greater?
3. Can we create a model that will successfully predict panicle size and yield traits based on specific QTLs or SNPs?

## Objective 1
### Can we specifically find loci that result in traits such as yield or panicle size?
Traits related to yield: PAN (panicle size), totPBL (total panicle biomass)
* grain weight shows potential yield of panicle because a larger panicle with heavier grains shows more grain can be produced per panicle


Traits related to panicle size: PBNin  (inner number of branches in panicle structure) PBN (number of branches in panicle strucutre)
"""

#group SNP_Names and find the average p-values of every trait for the specific SNP_Name
snp_trait_corr = pd.DataFrame({'SNP-NAME': df['SNP-NAME'], 'pVALUE': df['pVALUE'], 'TRAIT': df['TRAIT']})

grouped = snp_trait_corr.groupby(['SNP-NAME', 'TRAIT'])['pVALUE'].mean().reset_index()

snp_trait_corr['SNP-NAME'].unique().size

# Create heatmap data (rows: SNPs, columns: traits, values: -log10(p-values))
heatmap_data = pd.pivot_table(snp_trait_corr, values='pVALUE', index='SNP-NAME', columns='TRAIT')
heatmap_data.fillna(0, inplace=True)

plt.figure(figsize = (20,20))
sns.heatmap(heatmap_data, cmap='viridis')
plt.show()

#DO NOT USE THIS

import pandas as pd
import dash_bio
df_renamed = df.rename(columns={
    'CHROMOSOME': 'CHR',
    'pVALUE': 'P',
    'POSITION': 'BP',
    'SNP-NAME': 'SNP',
    'TRAIT': 'GENE'
})

dash_bio.ManhattanPlot(
    dataframe=df_renamed
)

"""According to the Manhatten plot
* Trait xPBN (panicle branch number)
* Trait PH (Plant Height)
* Trait BpN (Branches per Node)
* Trait BT (Basal Tillers)
* Trait PBLin (Primary Branch Length)
* Trait totPBL (total Primary Branch Length)
* Trait nNL (number of nodes with leaves)
* Trait NL (number of leaves)

exceed the threshold of the plot (peaks) so they suggest loci chromosome wise that are associtated with these traits

"""

sm.qqplot(df['pVALUE'], fit = True, line='45')
plt.title('Q-Q Plot for GWAS Results')
plt.show()

df.loc(df['CHROMOSOME'] == 1)

"""Manhattan Plot
* Shows results of GWAS
* Plots genomic positions of chromosomes on the x-axis against the statistical significance of association
* SNPs exceeding the threshold marked in red
* Chromosome 1, 5, 6, 7, 9 suggest that these may be associated with the trait we are studying

Q-Q Plot
* Compares p-value distributions with the null distribution
* red line represents null hypothesis where p-values match expected uniform distribution
* if no SNPs are associated with the trait the p-values should follow uniform distribution and observed quantiles shoudlalign closely with the theoretical quantiles (red line)
* points deviating above the diagonal in the upper right corner shows that the observed p-values are smaller than expected
  * this would mean some SNPs have strong associations with the trait causing the test statistic to yield small p-values

## Objective 2
### Do one of the subpopulations Indica, Japonica, Aus, Ind, or Trj show more significant results in SNPs or QTLs where yield or panicle size is greater?

If a subpopulations shows more significant SNPs and lower p-values, you can say it has stronger associations for traits we are looking for (yield and panicle size)
"""

p_threshold = 0.05
df_significant_traits = df[(df['pVALUE'] < p_threshold) &
                            (df['TRAIT'].isin(['xPBN', 'PH', 'BpN', 'BT', 'PBLin', 'totPBL', 'nNL', 'NL']))]

subpopulations = ['INDICA', 'JAPONICA', 'AUS', 'IND', 'TRJ']
df_subpop = {pop: df_significant_traits[df_significant_traits['SUB_POP'] == pop] for pop in subpopulations}

snp_counts = {pop: len(df) for pop, df in df_subpop.items()}
sns.barplot(x=list(snp_counts.keys()), y=list(snp_counts.values()))
plt.title("Count of Significant SNPs by Subpopulation")
plt.xlabel("Subpopulation")
plt.ylabel("Count of Significant SNPs")
plt.show()

combined_df = pd.concat(df_subpop.values(), keys=df_subpop.keys(), names=['Subpopulation'])
sns.boxplot(data=combined_df, x='Subpopulation', y='pVALUE')
plt.title("Distribution of P-values by Subpopulation")
plt.xlabel("Subpopulation")
plt.ylabel("-log10(P)")
plt.show()

#top 5 of the smallest p_valus for SNPs
top_5_snps = {pop: df.nsmallest(5, 'pVALUE') for pop, df in df_subpop.items()}
for pop, top_5_df in top_5_snps.items():
    print(f"Top SNPs for {pop}:\n", top_5_df[['SNP-NAME', 'pVALUE', 'TRAIT']])

"""* Trait xPBN - X
* Trait PH - X
* Trait BpN - X
* Trait BT - X
* Trait PBLin - X
* Trait totPBL - X
* Trait nNL - X
* Trait NL - X
"""

combined_df_reset = combined_df.reset_index()
combined_df_reset['Subpopulation'].unique()
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'INDICA']

print(f"Manhattan Plot for INDICA")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'INDICA']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for JAPONICA")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'JAPONICA']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for AUS")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'AUS']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for IND")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'IND']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for TRJ")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'TRJ']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

from scipy.stats import kruskal


p_values = [df_sp['pVALUE'] for df_sp in df_subpop.values()]
stat, p = kruskal(*p_values)
print(f"Kruskal-Wallis Test: H-statistic = {stat}, p-value = {p}")

significance_threshold = 5e-8

for pop in df_subpop.keys():
    df_filtered = df_subpop[pop]
    significant_snps = df_filtered[df_filtered['pVALUE'] < significance_threshold]
    proportion_significant = len(significant_snps) / len(df_filtered)
    print(f"{pop}: {len(significant_snps)} significant SNPs ({proportion_significant:.2%})")

"""###Testing values without filtering important TRAITS"""

p_threshold = 0.05
df_significant_traits = df[(df['pVALUE'] < p_threshold)]

subpopulations = ['INDICA', 'JAPONICA', 'AUS', 'IND', 'TRJ']
df_subpop = {pop: df_significant_traits[df_significant_traits['SUB_POP'] == pop] for pop in subpopulations}

snp_counts = {pop: len(df) for pop, df in df_subpop.items()}
sns.barplot(x=list(snp_counts.keys()), y=list(snp_counts.values()))
plt.title("Count of Significant SNPs by Subpopulation")
plt.xlabel("Subpopulation")
plt.ylabel("Count of Significant SNPs")
plt.show()

combined_df = pd.concat(df_subpop.values(), keys=df_subpop.keys(), names=['Subpopulation'])
sns.boxplot(data=combined_df, x='Subpopulation', y='pVALUE')
plt.title("Distribution of P-values by Subpopulation")
plt.xlabel("Subpopulation")
plt.ylabel("-log10(P)")
plt.show()

#top 5 of the smallest p_valus for SNPs
top_5_snps = {pop: df.nsmallest(5, 'pVALUE') for pop, df in df_subpop.items()}
for pop, top_5_df in top_5_snps.items():
    print(f"Top SNPs for {pop}:\n", top_5_df[['SNP-NAME', 'pVALUE', 'TRAIT']])

combined_df_reset = combined_df.reset_index()
combined_df_reset['Subpopulation'].unique()

print(f"Manhattan Plot for INDICA")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'INDICA']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

import dash_bio
print(f"Manhattan Plot for JAPONICA")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'JAPONICA']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for AUS")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'AUS']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for IND")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'IND']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

print(f"Manhattan Plot for TRJ")
df_subpop_filtered = combined_df_reset[combined_df_reset['Subpopulation'] == 'TRJ']
df_renamed_subpop = df_subpop_filtered.rename(columns={
'CHROMOSOME': 'CHR',
'pVALUE': 'P',
'POSITION': 'BP',
'SNP-NAME': 'SNP',
'TRAIT': 'GENE'
})
dash_bio.ManhattanPlot(dataframe=df_renamed_subpop)

"""## Objective 3
### Can we create a model that will successfully predict panicle size and yield traits based on specific QTLs or SNPs?
* Creating a Random Forest model
  * input: significant SNPs
  * output: predicted traits
* Cross validation to evaluate goodness of fit
* assess accuracy, precision, and recall using confusion matrix
"""

import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix
from sklearn import metrics
from sklearn.model_selection import StratifiedKFold
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import OneHotEncoder, LabelEncoder

"""### We will use traits from our results of the manhattan plot signifying which chromosomes or loci show the traits we are looking for
* Trait xPBN
* Trait PH
* Trait BpN
* Trait BT
* Trait PBLin
* Trait totPBL
* Trait nNL
* Trait NL

And then we will test if these chromosomes/SNPs will accurately predict the traits

This may be difficult because of the effects of pleiotropy so it will be interesting to see the results.



"""

# List of traits of interest
traits_of_interest = ['xPBN', 'PH', 'BpN', 'BT', 'PBLin', 'totPBL', 'nNL', 'NL']

# Filter SNPs associated with the selected traits
df_significant_snp = df[df['TRAIT'].isin(traits_of_interest)]


X = df_significant_snp.drop(columns=['TRAIT'])  # Input features (significant SNPs)
y = df_significant_snp['TRAIT']  # Output target (Panicle Size, or Yield)
non_numeric_columns = X.select_dtypes(include=['object', 'category']).columns

#use one-hot encoding
encoder = OneHotEncoder(sparse_output=False)
X = pd.get_dummies(X, columns=non_numeric_columns, drop_first=True)


label_encoder = LabelEncoder()
y = pd.DataFrame(label_encoder.fit_transform(y))
y
#80 training 20 testing split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# #using random forest classifier since traits can be categorical
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

predicted = rf_model.predict(X_test)
actual = y_test

confusion_matrix = metrics.confusion_matrix(actual, predicted)
cm_display = metrics.ConfusionMatrixDisplay(confusion_matrix = confusion_matrix)
cm_display.plot()

accuracy = accuracy_score(actual, predicted)
precision = precision_score(actual, predicted, average='weighted')
recall = recall_score(actual, predicted, average='weighted')
print(f"Accuracy: {accuracy}")
print(f"Precision: {precision}")
print(f"Recall: {recall}")

cv = StratifiedKFold(n_splits=10, shuffle=True, random_state=42)
cv_results = cross_val_score(rf_model, X, y, cv=cv, scoring='accuracy')
print(f"Cross-validation accuracy: {cv_results.mean():.2f} (+/- {cv_results.std():.2f})")


y_pred = rf_model.predict(X_test)


accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')

print(f"Accuracy: {accuracy:.4f}")
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")

predicted = rf_model.predict(X_test)
actual = y_test

confusion_matrix = metrics.confusion_matrix(actual, predicted)
cm_display = metrics.ConfusionMatrixDisplay(confusion_matrix = confusion_matrix)
cm_display.plot()

feature_importances = rf_model.feature_importances_

feature_names = X.columns
importance_df = pd.DataFrame({'Feature': feature_names, 'Importance': feature_importances})


importance_df = importance_df.sort_values(by='Importance', ascending=False)

print("Top 10 Important Features:")
print(importance_df.head(10))

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.barh(importance_df['Feature'].head(10), importance_df['Importance'].head(10), color='skyblue')
plt.xlabel('Importance Score')
plt.ylabel('Feature')
plt.title('Top 10 Feature Importances')
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()